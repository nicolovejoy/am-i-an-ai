/**
 * Shared message type definitions used by both frontend and backend
 */

export type MessageType = 'text' | 'system' | 'action' | 'reveal' | 'goal_update';
export type ModerationStatus = 'pending' | 'approved' | 'flagged' | 'rejected';
export type SentimentLabel = 'very_negative' | 'negative' | 'neutral' | 'positive' | 'very_positive';

export interface SentimentScore {
  label: SentimentLabel;
  confidence: number; // 0-1
  score: number; // -1 to 1
}

export interface MessageMetadata {
  wordCount: number;
  characterCount: number;
  readingTime: number; // estimated seconds
  complexity: number; // 0-1 (readability score)
  sentiment?: SentimentScore;
  topics?: string[];
  responseTime?: number; // ms from previous message
  typingTime?: number; // ms spent typing
  editCount?: number;
  language?: string;
  aiGenerated?: boolean; // true if generated by AI
}

export interface ModerationFlag {
  type: 'spam' | 'inappropriate' | 'off_topic' | 'harmful' | 'low_quality';
  severity: 'low' | 'medium' | 'high';
  confidence: number; // 0-1
  reason: string;
  flaggedAt: Date;
  reviewedAt?: Date;
  reviewedBy?: string;
  action?: 'none' | 'warn' | 'hide' | 'remove';
}

/**
 * Core message interface
 * Frontend uses camelCase, backend uses snake_case
 * Use transformation utilities to convert between formats
 */
export interface Message {
  id: string;
  conversationId: string;
  authorPersonaId: string;
  
  content: string;
  type: MessageType;
  timestamp: Date;
  sequenceNumber: number;
  
  // Message state
  isEdited: boolean;
  editedAt?: Date;
  originalContent?: string;
  
  // Threading (for future use)
  replyToMessageId?: string;
  threadId?: string;
  
  // Metadata for analysis
  metadata: MessageMetadata;
  
  // Moderation & safety
  moderationStatus: ModerationStatus;
  moderationFlags?: ModerationFlag[];
  isVisible: boolean;
  isArchived: boolean;
  
  // Reactions & feedback (for future use)
  reactions?: Record<string, string[]>; // emoji -> user IDs
  qualityRating?: number; // 1-5
}

/**
 * Backend message format (snake_case)
 * This interface represents how messages are stored in the database
 */
export interface MessageData {
  id: string;
  conversation_id: string;
  author_persona_id: string;
  content: string;
  type: MessageType;
  created_at: string;
  sequence_number: number;
  is_edited?: boolean;
  edited_at?: string;
  metadata?: any;
  moderation_status?: ModerationStatus;
  is_visible?: boolean;
  is_archived?: boolean;
}

export interface MessageCreate {
  conversationId: string;
  authorPersonaId: string;
  content: string;
  type?: MessageType;
  replyToMessageId?: string;
}

export interface MessageUpdate {
  content?: string;
  isVisible?: boolean;
  isArchived?: boolean;
  moderationStatus?: ModerationStatus;
}

export interface MessageThread {
  id: string;
  conversationId: string;
  parentMessageId: string;
  messages: Message[];
  participantCount: number;
  createdAt: Date;
  lastActivityAt: Date;
}

export interface MessageDraft {
  conversationId: string;
  authorPersonaId: string;
  content: string;
  lastUpdated: Date;
  version: number;
}

export interface TypingIndicator {
  conversationId: string;
  personaId: string;
  isTyping: boolean;
  timestamp: Date;
}

export interface MessageReaction {
  messageId: string;
  personaId: string;
  emoji: string;
  timestamp: Date;
}

export interface MessageStats {
  messageId: string;
  viewCount: number;
  reactionCount: number;
  replyCount: number;
  shareCount: number;
  qualityRating: {
    average: number;
    count: number;
  };
  engagementScore: number;
}

export interface ConversationHistory {
  conversationId: string;
  messages: Message[];
  participants: Array<{
    personaId: string;
    personaName: string;
    personaType: string;
  }>;
  totalCount: number;
  hasMore: boolean;
  nextCursor?: string;
}

export interface MessageSearch {
  query: string;
  conversationId?: string;
  authorPersonaId?: string;
  fromDate?: Date;
  toDate?: Date;
  messageType?: MessageType;
  sentimentRange?: [number, number];
  minLength?: number;
  maxLength?: number;
  topics?: string[];
  limit?: number;
  offset?: number;
}

export interface MessageSearchResult {
  message: Message;
  highlights: string[];
  relevanceScore: number;
  context: {
    previousMessage?: Message;
    nextMessage?: Message;
  };
}